# docker-compose.yml
services:
  postgres: # postgresql은 별도의 dockerfile 없이 바로 사용 가능
    image: postgres:18  # 최신 LTS 버전 사용
    container_name: postgres-db
    # environment: .env 파일의 변수를 자동으로 읽어옴 (dotenv처럼 작동)
    environment:
      POSTGRES_DB: ${DB_NAME}   
      POSTGRES_USER: ${DB_USER}   
      POSTGRES_PASSWORD: ${DB_PASSWORD} 
    ports:
      - "5432:5432"  # 호스트:컨테이너 포트 매핑
    volumes:
      # Named Volume: Docker가 관리하는 영구 저장소 (데이터 유지)
      - postgres_data:/var/lib/postgresql/
    # healthcheck: 다른 서비스들이 postgres 완전 준비될 때까지 대기하도록 함
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s  # 10초마다 체크
      timeout: 5s    # 5초 내 응답 없으면 실패
      retries: 5     # 5번 재시도

  # FastAPI 백엔드 (위에서 만든 Dockerfile 사용)
  backend:
    build: ./backend  # ./backend/Dockerfile 사용해서 이미지 빌드
    container_name: fastapi-server
    environment:
      DATABASE_URL: ${DB_URL}
    ports:
      - "8000:8000"
    # depends_on: postgres가 healthy 상태가 된 후에 backend 시작
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      # Bind Mount: 개발용 - 소스코드 실시간 반영
      - ./backend:/backend
    # command: Dockerfile의 CMD를 덮어씀
    command: uvicorn main:app --host 0.0.0.0 --port 8000

  # React 프론트엔드 (위에서 만든 Dockerfile 사용)
  frontend:
    build: ./frontend  # ./frontend/Dockerfile 사용해서 이미지 빌드
    container_name: react-app
    ports:
      - "3000:3000"
    environment:
      # React 앱에서 사용할 API URL 설정
      - REACT_APP_API_URL=http://localhost:8000

# volumes: Named Volume 정의 (데이터 영구 보존용)
volumes:
  postgres_data: